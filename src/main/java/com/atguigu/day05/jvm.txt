
JVM面试题：

请谈谈你对JVM的理解？java8的虚拟机有什么更新？

什么是OOM？什么是StackOverflowError？有哪些方法分析？
（请写一段代码演示OOM、StackOverflowError；OOM是错误还是异常？）

JVM常用参数调优你知道哪些？

谈谈JVM中，对类加载器你的认识？

-------------------------------------------------------

JVM架构图：

1. JVM体系结构概述
2. 堆体系结构概述
3. 堆参数调优
4. 总结


双亲委派：
当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。
采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.0biect，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。


Native Interface本地接口:
本地接口的作用是融合不同的编程语言为Java所用，它的初
衷是融合C/C++程序，Java 诞生的时候是C/C++横行的时候，要想立足，必须有调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies。
目前该方法使用的越来越少了，除非是与硬件有关的应用，比
如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。


Native Method Stack:
它的具体做法是Native Method Stack中登记native方法，在ExecutionEngine执行时加载本地方法库。

PC寄存器:
每个线程都有一个程序计数器，是线程私有的,就是一个指针，
指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码)，由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。
这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。如果执行的是一个Native方法，那这个计数器是空的。
用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出(Out0fMemory=0OM)错误

JVM体系图灰色代表2个意思：1）线程私有 2）这些地方内存占用非常少，几乎不存在GC垃圾回收

Method Area方法区
 供各线程共享的运行时内存区域。它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool)、字段和方法数据、构造函数和普通方法的字节码内容。上面讲的是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)。
But
实例变量存在堆内存中,和方法区无关


Stack栈
栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期是跟随线程的生命期，线程结束栈内存也就释放，
对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。
8种基本类型的变量 + 对象的引用变量 + 实例方法都是在函数的栈内存中分配。

栈存储什么?
栈帧中主要保存3类数据:
    本地变量(Local Variables）:输入参数和输出参数以及方法内的变量;
    栈操作（Operand Stack） :记录出栈、入栈的操作;
    栈帧数据（Frame Data）:包括类文件、方法等等。


7 Heap堆
一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分:
    Young Generation Space新生区   Young/New
    Tenure generation space养老区  old/ Tenure
    Permanent Space 永久区         Perm

新生区(如下是首次讲解，简单版，先入门大致理解，下一页ppt详细)
新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。
新生区又分为两部分:伊甸区(Eden space）和幸存者区(Survivor pace），所有的类都是在伊甸区被new出来的。
幸存区有两个:0区(Survivor 0 space）和1区(Survivor 1 space）。
当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。
然后将伊甸园中的剩余对象移动到幸存0区。
若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区。
那如果1区也满了呢?再移动到养老区。
若养老区也满了，那么这个时候将产生MajorGC (FullGC），进行养老区的内存清理。
若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemorvError”。
如果出现java.lang.OutOfMemoryError: Java heap space异常，说明Java虚拟机的堆内存不够。
原因有二:
    (1）Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。
    (2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。
