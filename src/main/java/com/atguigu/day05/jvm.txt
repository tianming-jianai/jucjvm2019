
JVM面试题：

请谈谈你对JVM的理解？java8的虚拟机有什么更新？

什么是OOM？什么是StackOverflowError？有哪些方法分析？
（请写一段代码演示OOM、StackOverflowError；OOM是错误还是异常？）

JVM常用参数调优你知道哪些？

谈谈JVM中，对类加载器你的认识？

-------------------------------------------------------

JVM架构图：

1. JVM体系结构概述
2. 堆体系结构概述
3. 堆参数调优
4. 总结


双亲委派：
当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载器中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。
采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.0biect，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。


Native Interface本地接口:
本地接口的作用是融合不同的编程语言为Java所用，它的初
衷是融合C/C++程序，Java 诞生的时候是C/C++横行的时候，要想立足，必须有调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies。
目前该方法使用的越来越少了，除非是与硬件有关的应用，比
如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。


Native Method Stack:
它的具体做法是Native Method Stack中登记native方法，在ExecutionEngine执行时加载本地方法库。

PC寄存器:
每个线程都有一个程序计数器，是线程私有的,就是一个指针，
指向方法区中的方法字节码（用来存储指向下一条指令的地址,也即将要执行的指令代码)，由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。
这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。如果执行的是一个Native方法，那这个计数器是空的。
用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出(Out0fMemory=0OM)错误

JVM体系图灰色代表2个意思：1）线程私有 2）这些地方内存占用非常少，几乎不存在GC垃圾回收

Method Area方法区
供各线程共享的运行时内存区域。它存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool)、字段和方法数据、构造函数和普通方法的字节码内容。上面讲的是规范，在不同虚拟机里头实现是不一样的，最典型的就是永久代(PermGen space)和元空间(Metaspace)。
But
实例变量存在堆内存中,和方法区无关


